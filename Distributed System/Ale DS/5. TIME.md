
## EVENTUALLY PERFECT FAILURE DETECTORS $◊P$

>**Algorithm**:![[Pasted image 20241014140726.png|500]]

**Strong Completeness**: if a process crashes, it will stop to send messages. Therefore the process will be suspected by any correct process and no process will revise the judgement.

**Eventual Strong Accuracy**: after time $t$ the system becomes synchronous. After that time a message sent by a correct process $p$ to another one $q$ will be delivered within a bounded time (the time is $MAX_{DELAY}$ unknown to us). If $p$ was wrongly suspected by $q$, then $q$ will revise its suspicious. Moreover $q$ increases its delay, if the new delay is less than $MAX_{DELAY}$, eventually $q$ suspects again $p$ and then it corrects again its delay. After a finite number of errors the delay of $q$ will be greater than $MAX_{DELAY}$.

Is possible that the deelay is big enough that can happen a situation where a process $p_2$ communicates at process $p_1$ that he's dead but the message is recived after the detection of $p_2$ dead line from $p_1$.
**Solution**: add brenches $T_x$.

**Property of Suspected**:
>**Lemma**: take two correct processes, $p_1$ and $p_2$ and let $suspected_1$ and $suspected_2$ be the respective sets. There is a time $t$ (stabilization time), after which $suspected_1=suspected_2$.


**Proof** (by contraddiction): suppose that exists a $p$ ina $suspected_1$ but not $suspected_2$:
- if $p$ is correct this violates the **eventual strong accuracy**.
- if $p$ crashed this violates the **strong completeness**.
___
## Leader Election

Sometimes, we may be interested in knowing one process that is alive instead of monitoring failures. In this case we can use a different oracle (called **leader election module**) that reports a process that is alive.

- **Name**: LeaderElection, **istance** $le$.
- **Indication**: $\langle le, Leader \hspace{5px}|\hspace{5px} p\rangle$: indicates that process $p$ **is elected as a leader**.
- **Properties**:
	- **LE1** (eventual detection): either there is no correct process, or some correct process is eventually elected as the leader (liveness property).
	- **LE2** (accuracy): if a process is leader, then all previously elected leaders have crashed
![[Pasted image 20241014143136.png|500]]
When $p_0$ dies it's okay because before he dies everyone know that he's the leader, but in $p_2$ after $p_0$ dead, the leader isn't changed. (broke the eventual detection property).

![[Pasted image 20241014143317.png|500]]
In this case the accuracy propery is broken because $p_2$ changes the leader even if $p_1$ is still alive.

>**Algorithm**:
![[Pasted image 20241014143525.png|500]]
$(\Pi \setminus suspected)$ is the subset of alive processes.

**Correctness**: 
- **Eventual detection**: from the strong completeness of $P$ (perfect failure).
- **Accuracy**: from the strong accuracy of $P$ and the total order on the ranks (IDs) of processes.

___
## Eventual Leader Election $\Omega$

- **Name**: $EventualLeaderDetector$, **istance** $\Omega$.
- **Indication**: $\langle \Omega , Trust \hspace{5px}|\hspace{5px} p\rangle$: indicates that process $p$ is trusted to be leader.
- **Properties**:
	- **ELD1** (eventual accuracy): there is a time after which every correct process trusts some correct process.
	- **ELD2** (eventual agreement): there ia time after which no two correct processes trust different correct processes.
Both of properties are **liveness**.

$\Omega$ ensures that **eventually** correct processes will elect the same correct process as their leader.

![[Pasted image 20241014150235.png|500]]

We can build an eventual leader election using **crash-stop process abstraction**:
- Obtained directly by $◊P$ by using a deterministic rule on processes that are not suspected by $◊P$.
- Trust the process with the highest identifier among all processes that are not suspected by $◊P$.

>**Algorithm**:![[Pasted image 20241014150514.png|500]]

**Proof**:
- **ELD1** (Eventual Accuracy): by the strong completeness of the FD we have that eventually suspected set contains all the crashed processes. Thus $\Pi \setminus suspected$ contains only correct processes (or its empty).
- **ELD2** (Eventual Agreement): for any pair of correct processes, their suspected sets eventually stabilises to the same content (by the property of the FD). If the set are equals $\Pi \setminus suspected$ returns the same ID on both processes.
___
## THREE MODELS

![[Pasted image 20241014150957.png|500]]![[Pasted image 20241014151033.png|500]]We can also say that the set of problems solvable in fail-stop includes the problems solvable in other models.

Relationship between Fail-Stop and SYNC:
![[Pasted image 20241014151416.png|500]]
SYNC is stronger than Fail-Stop (Correct answer is $B$ !!!!possibile domanda esame!!!!).
Problems we can solve with fail-stop is strictly contained in subset of problems we can solve with SYNC (SYNC can solve problems based on **time** like clock synchronization):![[Pasted image 20241014151751.png|250]]
___

## APPLICATION OF FAILURE DETECTOR AND LEADER ELECTOR


Using $P$ to make **Lamport’s Mutual Exclusion fault tolerant**.
**Events**:
- *Request*: from upper layer - requests access to Critical Section (CS).
- *Grant*: to upper layer - grant the access to CS.
- *Release*: from upper layer - release the CS.
**Properties**:
- **Mutual Exclusions**: at any time $t$, at most one non-crashed process is inside the CS.
- **Liveness**: if a correct process $p$ requests access, then it eventually enters the CS.
- **Fairness**: if a correct process $p$ requests access before a process $q$, then $q$ cannot access the CS before $p$.

![[Pasted image 20241014152236.png|500]]**Patch 1**:![[Pasted image 20241014152259.png|500]]If the system receive a request from $p_j$ after the crash detection we have a deadlock.
**Patch 2**:
![[Pasted image 20241014152858.png|500]]![[Pasted image 20241014152921.png|500]]If a process crashes I put a ban on all the events related to him.

>**Full Algorithm with Patches**: ![[Pasted image 20241014153001.png|500]]![[Pasted image 20241014154347.png|500]]

**Exercise**: write an algorithm with those properties:
- Use LE to elect a leader.
- Ask the leader for CS with a request message.
- The leader allows access to CS using FIFO order on requests.
- When done release CS using a release message.
- If the leader detects a crash $p$:
	- If $p$ is not in CS, it removes the pending request of $p$ (if any).
	- If $p$ is in CS, it acts as $p$ released the CS.
- *Problem*: what to do when a new leader is elected? The old leader was the only one to know who was in CS?
