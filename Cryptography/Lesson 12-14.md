## CCA Security
Going back to the encryption realm, a new definition of attack to a ske scheme will be introduced. Now the adversary can query a decryption oracle, along with the CPA-related encryption oracle, for polynomially many queries. This attack is called the Chosen Ciphertext Attack, and schemes that are proven to be CCA-secure are also defined as non-malleable, on the reasoning that an attacker cannot craft fresh valid ciphertexts from other valid ones. So, How to get both security and also authenticity?
**CCA**: Chosen-ciphertext attacks.

![[Pasted image 20241201152241.png]]

- L'avversario $A$ può:
    - Accedere a un **oracolo di cifratura** che fornisce la cifratura di messaggi a sua scelta.
    - Accedere a un **oracolo di decifratura**, con la limitazione che non può decifrare il ciphertext su cui è sfidato (vedi "challenge ciphertext").
- Fase del gioco:
    - L'avversario seleziona due messaggi, $m_0$ e $m_1$, di lunghezza uguale.
    - Il challenger sceglie un bit segreto $b \in {0, 1}$ e cifra il messaggio $m_b$, fornendo il ciphertext corrispondente all'avversario: $c^* = ENC(m_b)$.
    - L'avversario continua a interagire con l'oracolo di decifratura, ma **non può richiedere la decifratura di $c^*$**.
    - Alla fine, l'avversario restituisce un valore $\hat{b}$, che è la sua supposizione del valore di $b$.



```ad-abstract
title: Definition CCA Security
$\pi = (ENC,DEC)$ is CCA-secure if:
$$GAME^{cca}_{\lambda, A} (\lambda, 0) \approx_c GAME^{cca}_{\lambda, A} (\lambda, 1)$$

IL sistema è ((CCA-Secure)) se l'avversario non riesce a distinguere tra i due scenari.
```

>==Malleability==: ability to take some $c^*$ containing unknown $m^*$, and mail it into $\widetilde c \not = c^*$ such that you don't know the corresponding in $\widetilde m$, but you know $\widetilde m$ is related to $m^*$ (e.g. $m[1] = m^*[1]$)

Think of encrypted actions:

![[Cryptography/images/52.png]]
![[Cryptography/images/53.png]]

> **Observation**: CCA $\Rightarrow$ non-malleability! Questo significa che un attaccante non può manipolare un ciphertext per influenzare prevedibilmente il messaggio cifrato.

About the SKE scheme that we have already studied (CBC, OFB, CFB, CTR) are not CCA-Secure, this implies that are not malleable.

For instance: $c (r, F_k(r) \oplus m)$
Not CCA secure: $(r + U_n \text{is the randomness})$
What happens if we do: 
$c = (r,s)$
$\widetilde c = (r, s \oplus 10^{n-1})$ where
	$s = F_k (r) \oplus (m \oplus 10^{n-1})$
	Flipping first but of $s$

- L'attaccante "flippa" (cambia) il primo bit di $s$, il risultato della funzione pseudo-casuale applicata al messaggio.
- Anche se non conosce il contenuto di $m$, l'attaccante sa che il messaggio risultante $\widetilde{m}$ avrà un primo bit modificato rispetto a $m$.

Questo dimostra che il sistema **non è sicuro sotto CCA**, poiché è malleabile.


Make it on attack!
![[Cryptography/images/55.png]]
![[Cryptography/images/56.png]]

How do we get CCA security? An idea is to continue CPA security with UFCMA MAC.
Make sure CTX contains a tag of SMT. Then :
- The ciphertext (CTX) generated during encryption will include a **tag** generated by a secure MAC. This ensures that any tampering with the ciphertext can be detected during decryption.
	- If the tag is valid, the ciphertext is considered valid and is decrypted.
	- If the tag is invalid, the decryption outputs a special symbol like "$\bot$" (indicating an invalid ciphertext), ensuring security.

Attempts:

### Attempt 1: Adding tag directly into the CTX
Generate the ciphertext $c$ by encrypting the message $m$ with a key $k_1$
$$c \in ENC(k_1, m) \hspace{0.3cm} [CPA]$$
A tag $r$ is generated by authenticating the message $m$ with a key $k_2$:
$$c = TAG(k_2, m) \hspace{0.2cm} \text{[UFCMA]} \hspace{0.2cm}$$
The result is the complete ciphertext: 
$$c' = (c, r)$$
This construction is also ==not CPA-secure==, because $r$ might reveal information about the message $m$. 

```ad-example
If the tag is computed as $\widetilde{Tag}(k_2, m) = b \mid r$, where:
- $b$ is the first bit of $m$
- $r = Tag(k_2, m)$ 
an adversary could infer $b$ by observing the tag.

```

### Attempt 2: Encrypt the Tag
The problem was that $r$ can reveal something about $m$. Let's encrypt the tag:
We digit the message concatenated to the tag: $c' \leftarrow Enc(k_1, m \mid \mid r)$ where $r$ is calculated as $TAG(k_2, m)$. Only the encrypted ciphertext $c'$ is sent.

>This is used in TLS (Transport Layer Security)

This construction is also not CCA-secure because:
If the encryption algorithm is CPA-secure and the MAC is UF-CMA, it does not automatically guarantee CCA security. It is possible for an adversary to manipulate the ciphertext anyway.

$Enc = CPA \hspace{0.9cm} Tag=UF-CMA$
$c=(R,S) \hspace{0.9cm} s = F_{k_1}(r) \oplus (m \mid \mid r)$
$r = F_{k_2}(m)$
$e = b \mid \mid r'$

![[Cryptography/images/59.png]]

**Variante**:
- Viene definita una variante della funzione di cifratura $\widetilde{Enc}$, che prima cifra il messaggio $m$ usando il cifrario CPA ($Enc(k_1, m)$) e poi aggiunge una parte contenente il bit $b$. Questo approccio rende difficile distinguere tra i due possibili valori di $b$, ma non elimina completamente la vulnerabilità a CCA.
- **$\widetilde{Dec}(k_1, b \mid \mid c)$**: La funzione di decrittazione cerca di separare il bit $b$ dal ciphertext $c$. Il bit $b$ viene scartato, mentre $c$ viene decrittato per ottenere il messaggio originale. Se il ciphertext è stato modificato, il processo di decrittazione non sarà corretto, quindi l'autenticità e l'integrità del messaggio vengono verificate.
- Si conclude che questa variante della cifratura è equivalente a una cifratura CPA sicura, ma non raggiunge la sicurezza CCA. Questo è un punto importante perché, anche se il sistema è sicuro contro attacchi CPA (dove l'attaccante può scegliere i messaggi da cifrare), non è sufficientemente sicuro contro attacchi CCA (dove l'attaccante può anche tentare di manipolare i ciphertext già cifrati).

![[Cryptography/images/60.png]]
$\widetilde{Enc} (k_1, m) = b \mid \mid Enc(k_1, m)$
$b \leftarrow \{0,1\}$
$Enc = CPA$
$\widetilde Dec(k_1, b \mid \mid c): \hspace{0.5cm} \text{Discard} \hspace{0.5cm} b \hspace{0.5cm} \text{Derypt} \hspace{0.5cm} c$
$\widetilde Enc \equiv CPA!$


### Attempt 3:  Separate the cipher text and the tag
You generate the ciphertext by encrypting the message with a $k_1$ key:
$$c \leftarrow Enc(k_1, m)$$
We compute the tag by authenticating the ciphertext with a $k_2$ key:
$$r = Tag(k_2, c)$$
Il risultato è il ciphertext completo: 
$$c' = (c, r)$$
```ad-abstract
title: Theorem
If the encryption algorithm $(ENC, DEC)$ is CPA-secure and the authentication algorithm $TAG$ is UF-CMA, then the resulting system $(ENC', DEC')$ is CCA-secure.

```

**General Technique**: CCA Security follows from two isolated properties:
-  CPA security
- Authenticity $\rightarrow$ Not possible to create valid ctx without key

![[Cryptography/images/61.png]]

-----
-----
Let $Tag_1, Tag_2$ be MACs. We know that at last one of them is UF-CMA, but not which one.
Show how to construct Tag that is UF-CMA using both $Tag_1, Tag_2$.
Suggestion: $Tag(k,m) = Tag_1(k_1, m) \mid \mid Tag_2(k_2, m)$

## CCA Security (cont'd)
For the proof of approach 3), we need a lemma:
```ad-abstract
title: Lemma
Assuming $\pi=(ENC, DEC)$ satisfies both CPA and AUTH, then $\pi$ is CCA-Secure

```

Proof of this lemma:
Main idea: Make a reduction from CPA to CCA.

Intuition: A CPA needs to answer decryption queries explaining truth property.
Auth means no $A$ can make valid $\tilde c$ so just answer Dec query with ?????
Upon decryption query $c'$:
- If $c' \in \{c\}$ returned in a previous encryption query $m$, return $m$.
- Else, answer $\bot$

Bad Event: $A_{cca}$ makes $\tilde c$ dec query such that $\tilde c \not \in \{c\}$ and $Dec(k, \tilde c) \not = ????$
By AUTH: $Pr[BAD] \le negl(\epsilon)$

```ad-abstract
title: Lemma
Approeac 3) satisfies both CPA and Auth

```


```ad-check
title: CHATGPT Risposta
### **Sicurezza CCA (Continua)**

#### **Lemma**

Il seguente lemma riguarda la sicurezza CCA di un sistema crittografico π=(ENC,DEC)\pi = (ENC, DEC)π=(ENC,DEC):

Se π=(ENC,DEC) soddisfa sia CPA che AUTH, allora π eˋ CCA-Secure.\text{Se } \pi = (ENC, DEC) \text{ soddisfa sia CPA che AUTH, allora } \pi \text{ è CCA-Secure}.Se π=(ENC,DEC) soddisfa sia CPA che AUTH, allora π eˋ CCA-Secure.

#### **Dimostrazione del Lemma**

L'idea principale è fare una **riduzione** dalla sicurezza CPA alla sicurezza CCA. In altre parole, supponiamo che il sistema sia sicuro contro gli attacchi CPA e autentico (AUTH), e vogliamo dimostrare che è anche sicuro contro gli attacchi CCA.

**Intuizione**:

- La sicurezza CPA garantisce che, dato un messaggio scelto dal nemico, il sistema cifra il messaggio in modo tale che l'attaccante non possa distinguerlo da un altro messaggio.
- L'autenticità (AUTH) significa che l'attaccante non può generare un ciphertext valido senza conoscere la chiave segreta.

### **Funzionamento della riduzione**

1. **Iniziare con una query di decrittazione**: Quando l'attaccante invia una query di decrittazione, la risposta dipende da se il ciphertext c′c'c′ è stato già cifrato in una precedente query di cifratura. Se c′c'c′ è uno dei ciphertext precedenti, restituiamo il messaggio decifrato corrispondente.
    
2. **Cosa fare se c′c'c′ è nuovo**: Se c′c'c′ non è stato mai visto prima (non è uno dei ciphertext precedentemente cifrati), rispondiamo con ⊥\bot⊥ (indica che il ciphertext non è valido o che l'attaccante ha tentato di manipolare il ciphertext).
    
3. **Evento "cattivo" (Bad Event)**: L'evento "cattivo" si verifica quando l'attaccante AccaA_{cca}Acca​ riesce a generare un ciphertext c~\tilde{c}c~ che non è stato precedentemente cifrato, ma quando lo decripta, non ottiene ⊥\bot⊥. Questo significa che l'attaccante è riuscito a manipolare il ciphertext in modo che il sistema non rifiuti la sua query di decrittazione, violando quindi la sicurezza.
    
4. **Probabilità dell'evento "cattivo"**: La probabilità che l'attaccante AccaA_{cca}Acca​ generi un ciphertext valido nonostante non conosca la chiave è limitata dalla proprietà di autenticità (AUTH). Poiché non è possibile per l'attaccante creare un ciphertext valido senza la chiave, la probabilità dell'evento "cattivo" è molto bassa, precisamente:
    
    Pr⁡[BAD]≤negl(ϵ)\Pr[BAD] \le \text{negl}(\epsilon)Pr[BAD]≤negl(ϵ)
    
    dove negl(ϵ)\text{negl}(\epsilon)negl(ϵ) è una funzione trascurabile (ossia che diminuisce rapidamente con l'aumentare della sicurezza).

```






**Proof of this lemma**
Approach 3):
$$c' = Enc((k_1, k_2), m) = (c,r)$$
$$c \Leftarrow Enc(k_1, m); \hspace{0.8cm} r = Tag(k_2, c)$$
Let's start with CPA. By reduction to CPA ???? of $(ENC, DEC) = \pi_1$ 





It remains to show AUTH. Reduction to? UF-MA of Tag.


When does $A_{\text{auth}}$ win? If:
1) $Tag(k_2, c^{*}) = r^*$
2) $(c^*, r^*)$ fresh: $\not = \{(c,r)\}$

When does $A_2$ win? If:
1) Tag(k_2, c^*) = r^*
2) $c^*$ fresh: $\not = \{c\}$

What is one bad scheme:
$\tilde{\text{Tag}}(k,n) = 0 \mid \mid Tag(k,m)$
Bob: Discard first bit and check $r$

Still UF-CMA, because you can forge tag only in messages for which you already queried the callenger.

Away out: Assume each message has a unique tag alternatively, do not assume that but assume that they?? satisfies: STRONG UF-CMA.


## Blockciphers
In practice: AES, DES, 3DES
In theory: Pseudorandom permutation (PRP)

PRP are efficiently invertible: 
$$\exists \hspace{0,1cm} PPT F^{-1} \hspace{0,3cm} \text{such that} \hspace{0,3cm} F^{-1}_k(F_k(x)) = x \hspace{0.5cm} \forall x$$
e.g. - some modes of equation require this. How to build a PRP? Two approaches:
- Proverbially secure ??: Assume hardness of number theoretic problems (Factoring, discrete log, $\cdots$) or in fact any OWF.
	$$OWF \Rightarrow PRG \Rightarrow PRF \Rightarrow PRP$$
- Heuristic. Heuristically build a PRF and then make it a PRP (e.g. DES) as the theoretical would do (almost).
	The so-called Feistel Network.
	LET $F: \{0,1\}^n \Rightarrow \{0,1\}^n$ be a function (maybe a PRF). How to make it invertible?

	$$\xi_f(X,Y) = (Y, X \oplus F(y)) = (x', y')$$
	Not a PRP! $\exists$ PPT A that breaks it w.p. $1-2^{-n}$. But we can stack it.

	Still invertible! But not a PRP!
	Note: $\xi_{F, F'}(x,y) \oplus \xi_{F, F'}(x', y) = (x \oplus x', .....)$ 
	Okay, do it another ti

```ad-abstract
title: Theorem
$\xi_{F, F', F''}$ IS A prp assuming $F, F', F''$ are PRFs.
$$F=\{F_k : \{0,1\}^n \to \{0,1\}^n\}$$
$$F \equiv F_{k_1} ; F' \equiv F_{k_2}; F'' \equiv F_{k_3}$$
$$k_1, k_2, k_3 \leftarrow U_{\lambda}$$

```

DES: $r=18$ rounds! $F$ is heuristic (confusion + diffusion); $k_1, k_@, k_3, \cdots, k_18$
Derived from some $K$ (using heuristic PRG)
Intuition for The proof:

```ad-missing
Fare i quattro disegni mancanti

```









