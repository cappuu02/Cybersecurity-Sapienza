## CCA Security
Going back to the encryption realm, a new definition of attack to a ske scheme will be introduced. Now the adversary can query a decryption oracle, along with the CPA-related encryption oracle, for polynomially many queries. This attack is called the Chosen Ciphertext Attack, and schemes that are proven to be CCA-secure are also defined as non-malleable, on the reasoning that an attacker cannot craft fresh valid ciphertexts from other valid ones. So, How to get both security and also authenticity?
**CCA**: Chosen-ciphertext attacks.

![[Pasted image 20241201152241.png]]

- L'avversario $A$ può:
    - Accedere a un **oracolo di cifratura** che fornisce la cifratura di messaggi a sua scelta.
    - Accedere a un **oracolo di decifratura**, con la limitazione che non può decifrare il ciphertext su cui è sfidato (vedi "challenge ciphertext").
- Fase del gioco:
    - L'avversario seleziona due messaggi, $m_0$ e $m_1$, di lunghezza uguale.
    - Il challenger sceglie un bit segreto $b \in {0, 1}$ e cifra il messaggio $m_b$, fornendo il ciphertext corrispondente all'avversario: $c^* = ENC(m_b)$.
    - L'avversario continua a interagire con l'oracolo di decifratura, ma **non può richiedere la decifratura di $c^*$**.
    - Alla fine, l'avversario restituisce un valore $\hat{b}$, che è la sua supposizione del valore di $b$.



```ad-abstract
title: Definition CCA Security
$\pi = (ENC,DEC)$ is CCA-secure if:
$$GAME^{cca}_{\lambda, A} (\lambda, 0) \approx_c GAME^{cca}_{\lambda, A} (\lambda, 1)$$

IL sistema è ((CCA-Secure)) se l'avversario non riesce a distinguere tra i due scenari.
```

>==Malleability==: ability to take some $c^*$ containing unknown $m^*$, and mail it into $\widetilde c \not = c^*$ such that you don't know the corresponding in $\widetilde m$, but you know $\widetilde m$ is related to $m^*$ (e.g. $m[1] = m^*[1]$)

Think of encrypted actions:

![[Cryptography/images/52.png]]
![[Cryptography/images/53.png]]

> **Observation**: CCA $\Rightarrow$ non-malleability! Questo significa che un attaccante non può manipolare un ciphertext per influenzare prevedibilmente il messaggio cifrato.

About the SKE scheme that we have already studied (CBC, OFB, CFB, CTR) are not CCA-Secure, this implies that are not malleable.

For instance: $c (r, F_k(r) \oplus m)$
Not CCA secure: $(r + U_n \text{is the randomness})$
What happens if we do: 
$c = (r,s)$
$\widetilde c = (r, s \oplus 10^{n-1})$ where
	$s = F_k (r) \oplus (m \oplus 10^{n-1})$
	Flipping first but of $s$

- L'attaccante "flippa" (cambia) il primo bit di $s$, il risultato della funzione pseudo-casuale applicata al messaggio.
- Anche se non conosce il contenuto di $m$, l'attaccante sa che il messaggio risultante $\widetilde{m}$ avrà un primo bit modificato rispetto a $m$.

Questo dimostra che il sistema **non è sicuro sotto CCA**, poiché è malleabile.


Make it on attack!
![[Cryptography/images/55.png]]
![[Cryptography/images/56.png]]

How do we get CCA security? An idea is to continue CPA security with UFCMA MAC.
Make sure CTX contains a tag of SMT. Then :
- The ciphertext (CTX) generated during encryption will include a **tag** generated by a secure MAC. This ensures that any tampering with the ciphertext can be detected during decryption.
	- If the tag is valid, the ciphertext is considered valid and is decrypted.
	- If the tag is invalid, the decryption outputs a special symbol like "$\bot$" (indicating an invalid ciphertext), ensuring security.

Attempts:

### Attempt 1: Adding tag directly into the CTX
Generate the ciphertext $c$ by encrypting the message $m$ with a key $k_1$
$$c \in ENC(k_1, m) \hspace{0.3cm} [CPA]$$
A tag $r$ is generated by authenticating the message $m$ with a key $k_2$:
$$c = TAG(k_2, m) \hspace{0.2cm} \text{[UFCMA]} \hspace{0.2cm}$$
The result is the complete ciphertext: 
$$c' = (c, r)$$
This construction is also ==not CPA-secure==, because $r$ might reveal information about the message $m$. 

```ad-example
If the tag is computed as $\widetilde{Tag}(k_2, m) = b \mid r$, where:
- $b$ is the first bit of $m$
- $r = Tag(k_2, m)$ 
an adversary could infer $b$ by observing the tag.

```

### Attempt 2: Encrypt the Tag
The problem was that $r$ can reveal something about $m$. Let's encrypt the tag:
We digit the message concatenated to the tag: $c' \leftarrow Enc(k_1, m \mid \mid r)$ where $r$ is calculated as $TAG(k_2, m)$. Only the encrypted ciphertext $c'$ is sent.

>This is used in TLS (Transport Layer Security)

This construction is also not CCA-secure because:
If the encryption algorithm is CPA-secure and the MAC is UF-CMA, it does not automatically guarantee CCA security. It is possible for an adversary to manipulate the ciphertext anyway.

$Enc = CPA \hspace{0.9cm} Tag=UF-CMA$
$c=(R,S) \hspace{0.9cm} s = F_{k_1}(r) \oplus (m \mid \mid r)$
$r = F_{k_2}(m)$
$e = b \mid \mid r'$

![[Cryptography/images/59.png]]

**Variante**:
- Viene definita una variante della funzione di cifratura $\widetilde{Enc}$, che prima cifra il messaggio $m$ usando il cifrario CPA ($Enc(k_1, m)$) e poi aggiunge una parte contenente il bit $b$. Questo approccio rende difficile distinguere tra i due possibili valori di $b$, ma non elimina completamente la vulnerabilità a CCA.
- **$\widetilde{Dec}(k_1, b \mid \mid c)$**: La funzione di decrittazione cerca di separare il bit $b$ dal ciphertext $c$. Il bit $b$ viene scartato, mentre $c$ viene decrittato per ottenere il messaggio originale. Se il ciphertext è stato modificato, il processo di decrittazione non sarà corretto, quindi l'autenticità e l'integrità del messaggio vengono verificate.
- Si conclude che questa variante della cifratura è equivalente a una cifratura CPA sicura, ma non raggiunge la sicurezza CCA. Questo è un punto importante perché, anche se il sistema è sicuro contro attacchi CPA (dove l'attaccante può scegliere i messaggi da cifrare), non è sufficientemente sicuro contro attacchi CCA (dove l'attaccante può anche tentare di manipolare i ciphertext già cifrati).

![[Cryptography/images/60.png]]
$\widetilde{Enc} (k_1, m) = b \mid \mid Enc(k_1, m)$
$b \leftarrow \{0,1\}$
$Enc = CPA$
$\widetilde Dec(k_1, b \mid \mid c): \hspace{0.5cm} \text{Discard} \hspace{0.5cm} b \hspace{0.5cm} \text{Derypt} \hspace{0.5cm} c$
$\widetilde Enc \equiv CPA!$


### Attempt 3:  Separate the cipher text and the tag
You generate the ciphertext by encrypting the message with a $k_1$ key:
$$c \leftarrow Enc(k_1, m)$$
We compute the tag by authenticating the ciphertext with a $k_2$ key:
$$r = Tag(k_2, c)$$
Il risultato è il ciphertext completo: 
$$c' = (c, r)$$
```ad-abstract
title: Theorem
If the encryption algorithm $(ENC, DEC)$ is CPA-secure and the authentication algorithm $TAG$ is UF-CMA, then the resulting system $(ENC', DEC')$ is CCA-secure.

```

**General Technique**: CCA Security follows from two isolated properties:
-  CPA security
- Authenticity $\rightarrow$ Not possible to create valid ctx without key

![[Cryptography/images/61.png]]

-----
-----
Let $Tag_1, Tag_2$ be MACs. We know that at last one of them is UF-CMA, but not which one.
Show how to construct Tag that is UF-CMA using both $Tag_1, Tag_2$.
Suggestion: $Tag(k,m) = Tag_1(k_1, m) \mid \mid Tag_2(k_2, m)$

## CCA Security (cont'd)
For the proof of approach 3), we need a lemma:
```ad-abstract
title: Lemma
Assuming $\pi=(ENC, DEC)$ satisfies both CPA and AUTH, then $\pi$ is CCA-Secure

```

**Proof of the lemma**:
The ==main idea== is to make a reduction from CPA security to CCA security. In other words, we assume that the system is secure against CPA and authentic (AUTH) attacks, and we want to show that it is also secure against CCA attacks.

**Intuition**: 
- La ==sicurezza CPA== garantisce che, dato un messaggio scelto dal nemico, il sistema cifra il messaggio in modo tale che l'attaccante non possa distinguerlo da un altro messaggio.
- ==L'autenticità (AUTH)== significa che l'attaccante non può generare un ciphertext valido senza conoscere la chiave segreta.

How it work:
1. When the attacker sends a decryption query, the response depends on whether the ciphertext $c'$ has already been encrypted in a previous encryption query. If $c'$ is one of the previous ciphertexts, we return the corresponding decrypted message.
2. Se $c'$ non è stato mai visto prima (non è uno dei ciphertext precedentemente cifrati), rispondiamo con $\bot$ (indica che il ciphertext non è valido o che l'attaccante ha tentato di manipolare il ciphertext).

A ==bad event== occurs when the attacker $A_{cca}$ succeeds in generating a ciphertext $\tilde{c}$ that has not been previously encrypted, but when it decrypts it, it does not get $\bot$. This means that the attacker has managed to manipulate the ciphertext so that the system does not reject its decryption query, thus violating security.

La **probabilità** che l'attaccante $A_{cca}$​ generi un ciphertext valido nonostante non conosca la chiave è limitata dalla proprietà di autenticità (AUTH). Poiché non è possibile per l'attaccante creare un ciphertext valido senza la chiave, la probabilità dell'evento "cattivo" è molto bassa, precisamente:

$$Pr[BAD] \le \text{negl}(\epsilon)$$

```ad-abstract
title: Lemma
Approach 3 satisfies both CPA and AUTHENTICATION.

```

**Proof of this lemma**
Approach 3):
$$c' = Enc((k_1, k_2), m) = (c,r)$$
$$c \Leftarrow Enc(k_1, m); \hspace{0.8cm} r = Tag(k_2, c)$$

The idea is to show that if the basic cipher $(ENC, DEC)$ is CPA-secure, then the combined system also remains CPA-secure. The tag $r = Tag(k_2, c)$ reveals nothing new about the message information $m$, since:
- $Tag(k_2, c)$ è calcolato sul ciphertext ccc, che è già CPA-secure.
- La chiave $k_2$​ è separata e non influisce sul processo di cifratura.

Let's start with CPA. By reduction to CPA ???? of $(ENC, DEC) = \pi_1$ 

![[WhatsApp Image 2024-12-02 at 14.19.05.jpeg|500]]

```ad-info
![[Pasted image 20241202143149.png]]

```


It remains to show AUTH. Reduction to? UF-MA of Tag.

![[Pasted image 20241202142008.png|500]]

When does $A_{\text{auth}}$ win? If:
1) $Tag(k_2, c^{*}) = r^*$
2) $(c^*, r^*)$ fresh: $\not = \{(c,r)\}$

When does $A_2$ win? If:
1) $Tag(k_2, c^*) = r^*$
2) $c^*$ fresh: $\not = \{c\}$

>La connessione tra $A_{\text{auth}}$​ consiste nel fatto che, se $A_{\text{auth}}$ può generare un $(c^*, r^*)$ valido e fresco, allora $A_2$ può fare lo stesso, violando la proprietà UF-CMA di $Tag$.

Problematic Scheme: 
$$\tilde{\text{Tag}}(k,n) = 0 \mid \mid Tag(k,m)$$
The tag is constructed by concatenating an initial zero to the original tag $Tag(k, m)$.
Although Bob discards the first bit and verifies the tag $r$, the pattern remains UF-CMA only in a limited way. It is possible to forge the tag only for messages that the attacker has already requested from the system.

==Solutions==:
- **Assume that each message has a unique tag**: This simplifies the problem by ensuring that each rrr tag is distinct, avoiding ambiguity.
- **Require a stronger MAC property (Strong UF-CMA):** A strengthened version of the UF-CMA property, where no valid tags can be generated for any message, regardless of the number of queries made to the system.

## Blockciphers

```ad-abstract
title: Definition
==Block ciphers== are cryptographic algorithms that operate on fixed-size blocks of data. They are used in modes of operation to encrypt larger datasets. 

```

>**Obiettivo principale:** trasformare un blocco di testo in chiaro in un blocco cifrato, mantenendo sicurezza e riservatezza.

The **practical** examples provided are:
- AES
- DES
- 3DES

In **theory**, these are modeled as **Pseudorandom Permutations (PRPs)**, which are efficiently invertible (Knowing the key you can retrieve the original message).

>Un PRP può essere visto come un PRF con la proprietà aggiuntiva di essere invertibile.

![[WhatsApp Image 2024-12-02 at 14.42.57.jpeg]]

A PRP ensures that for any input and key, the output is indistinguishable from random, but the function is efficiently invertible with the key. Formally:
$$\exists \hspace{0,1cm} PPT F^{-1} \hspace{0,3cm} \text{such that} \hspace{0,3cm} F^{-1}_k(F_k(x)) = x \hspace{0.5cm} \forall x$$

**Building PRPs**
- **Provably secure approach:** Relies on hard problems like factoring or discrete logarithms to construct cryptographic primitives.$$OWF \Rightarrow PRG \Rightarrow PRF \Rightarrow PRP$$
- **Heuristic approach:** Starts by heuristically building a PRF and then converting it into a PRP. An example can be the so-called Feistel Network.



### Feistel Networks
A Feistel Network transforms a function $F$ into an invertible construction. 
Let $F: \{0,1\}^n \Rightarrow \{0,1\}^n$ be a function (maybe a PRF). How to make it invertible?
$$\xi_f(X,Y) = (Y, X \oplus F(y)) = (x', y')$$
Here:
- $X$ and $Y$ are halves of the input.
- $\oplus$ denotes XOR.
- $F$ is any function, potentially a PRF.

```ad-warning
A single round of a Feistel Network is not secure as a PRP because there exists a probabilistic polynomial-time (PPT) adversary that can distinguish it with high probability.

```

```ad-success
title: Solution
By adding more rounds and ensuring $F, F', F''$ are PRFs, the construction becomes a PRP.

```


#### One Round Feistel Network
This diagram represents a **one-round Feistel network**, which is not yet a secure pseudorandom permutation (PRP).
![[WhatsApp Image 2024-12-02 at 14.43.04.jpeg]]
Is not a PRP because While $\xi_F$​ is **invertible** (you can recover $X$ from $X'$ using $X = X' \oplus F(Y)$, it is **not indistinguishable from a random permutation**. A probabilistic polynomial-time (PPT) adversary can exploit this structure to "break" its security with probability close to $1$, specifically $1 - 2^{-n}$, where $n$ is the block size in bits.

Remember:
- $X$ = The left half of the input.
- $Y$ = The right half of the input.

#### Two round Feistel Network 
This diagram represents a **two-round Feistel network**, an improvement over the first game.
![[WhatsApp Image 2024-12-02 at 14.43.13.jpeg]]
It's still not a PRP: 
Although adding a second round improves the diffusion (mixing of input bits), this structure is **still not a secure pseudorandom permutation**. A determined adversary might still find patterns or correlations in the output that betray its deterministic nature. Increasing the number of rounds further (e.g., 16 rounds in DES) typically results in a structure that can heuristically achieve PRP-like security.

>Both games are invertible, meaning you can recover the original input $(X,Y)$ from the output by reversing the steps.

```ad-abstract
title: Theorem
$\xi_{F, F', F''}$ IS A prp assuming $F, F', F''$ are PRFs.
$$F=\{F_k : \{0,1\}^n \to \{0,1\}^n\}$$
$$F \equiv F_{k_1} ; F' \equiv F_{k_2}; F'' \equiv F_{k_3}$$
$$k_1, k_2, k_3 \leftarrow U_{\lambda}$$

```

>Questo teorema afferma che se $F'F,F′$ sono buone funzioni pseudocasuali (PRF), allora una rete di Feistel con tre round diventa una permutazione pseudocasuale sicura (PRP).

```ad-success
Spiegazione esaustiva:
L'intuizione alla base di questo risultato si basa sulle proprietà delle PRF e sulla struttura della rete di Feistel:

1. **Proprietà delle PRF:**
    
    - Ogni FkF_kFk​ si comporta come una funzione casuale per una chiave casuale kkk. Questa casualità garantisce che ogni round della rete di Feistel mescoli efficacemente l'input.
2. **Indipendenza delle chiavi:**
    
    - Le chiavi k1,k2,k3k_1, k_2, k_3k1​,k2​,k3​ sono scelte indipendentemente. Questo impedisce correlazioni tra i risultati dei diversi round, che potrebbero essere sfruttate da un avversario.
3. **Struttura della rete di Feistel:**
    
    - La struttura di Feistel garantisce che la rete sia invertibile, anche se le funzioni F,F′,F′′F, F', F''F,F′,F′′ non lo sono. Questo è cruciale per costruire una PRP.
4. **Confusione e diffusione:**
    
    - La rete di Feistel assicura **confusione** (mescolamento dei bit dell'input) e **diffusione** (distribuzione delle dipendenze dell'input nei bit dell'output). Dopo diversi round, l'output risulta indistinguibile da un comportamento casuale.
5. **Più round = maggiore sicurezza:**
    
    - Un singolo round non è sicuro, ma ogni round aggiuntivo rende più difficile per un avversario distinguere il risultato da una permutazione casuale.
    - Tre round sono sufficienti per garantire sicurezza teorica, secondo certe tecniche di dimostrazione.

```



![[WhatsApp Image 2024-12-02 at 14.44.13.jpeg]]

![[WhatsApp Image 2024-12-02 at 14.44.20.jpeg]]

![[WhatsApp Image 2024-12-02 at 14.44.33.jpeg]]

![[WhatsApp Image 2024-12-02 at 14.44.27.jpeg]]







